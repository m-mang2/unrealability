![image](https://github.com/m-mang2/unrealability/assets/135841268/21664534-fc83-4106-858b-337ba665c82a)


AnimMontage에서 특정 시점에 notify를 설정

![image](https://github.com/m-mang2/unrealability/assets/135841268/8bb2235b-a528-4531-ab43-7685540c519d)

Tag는 SkillHitCheck

![image](https://github.com/m-mang2/unrealability/assets/135841268/724e7807-f79b-48e2-8594-1d6a9a640211)


Character에 SkillHitCheck를 설정

```
for (const auto& StartAbility : StartAbilities)
{
  FGameplayAbilitySpec StartSpec(StartAbility);
  //StartSpec.InputID = InputID++;
  ASC->GiveAbility(StartSpec);
}
```
![image](https://github.com/m-mang2/unrealability/assets/135841268/a8466452-3281-41c5-bfe5-066990d7e458)



GameplayAbility는 AnimMontage의 notify에서 호출이됨

GameplayAbility가 호출이 되면 ActivateAbility내에서 UAbilityTask를 생성하는데 UAbilityTask내에서 판정이 나옴



```
UABAT_Trace* AttackTraceTask = UABAT_Trace::CreateTask(this, AABTA_Trace::StaticClass()); // AGameplayAbilityTargetActor는  UABAT_Trace::CreateTask이용하여 생성
if (AttackTraceTask)
{
	AttackTraceTask->OnComplete.AddDynamic(this, &UABGA_AttackHitCheck::OnTraceResultCallBack);
	AttackTraceTask->ReadyForActivation();
}
```

판정을 위하여  AABTA_SphereMultiTrace라는 객체를 생성하여 FGameplayAbilityTargetDataHandle를 만들어서 넘김
```

FGameplayAbilityTargetDataHandle AABTA_SphereMultiTrace::MakeTargetData() const
{
	ABGAS_LOG(LogABGAS, Log, TEXT("Begin"));

	ACharacter* Character = CastChecked<ACharacter>(SourceActor);

	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(SourceActor);
	if (ASC == nullptr)
	{
		return FGameplayAbilityTargetDataHandle();
	}

	TArray<FOverlapResult> Overlaps; // 범위에 있는 모든 객체들의 정보
	const float SkillRadius = 600.0f;
	FVector Origin = Character->GetActorLocation();
	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(AABTA_SphereMultiTrace), false, Character);
	GetWorld()->OverlapMultiByChannel(Overlaps, Origin, FQuat::Identity, CCHANNEL_ABACTION, FCollisionShape::MakeSphere(SkillRadius), QueryParams);


	TArray<TWeakObjectPtr<AActor>> HitActors;
	for (const auto& Overlap : Overlaps)
	{
		AActor *HitActor = Overlap.OverlapObjectHandle.FetchActor<AActor>();
		if (HitActor && HitActors.Contains(HitActor) == false)
		{
			HitActors.Add(HitActor);
		}
	}

	FGameplayAbilityTargetData_ActorArray* ActorData = new FGameplayAbilityTargetData_ActorArray();
	ActorData->SetActors(HitActors);

	return FGameplayAbilityTargetDataHandle(ActorData);
}

```

조건을 체크하여 액터를 넘기면 OnTraceResultCallBack에서 액터들을 확인하여 이펙트를 보냄
```
UAbilitySystemComponent* SourceASC = GetAbilitySystemComponentFromActorInfo_Checked();
FGameplayEffectSpecHandle EffectSpecHandle = MakeOutgoingGameplayEffectSpec(AttackDamageEffect, CurrentLevel);
if (EffectSpecHandle.IsValid())
{
	ApplyGameplayEffectSpecToTarget(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, EffectSpecHandle, TargetDatahandle);

	FGameplayEffectContextHandle CueContextHandle = UAbilitySystemBlueprintLibrary::GetEffectContext(EffectSpecHandle);
	CueContextHandle.AddActors(TargetDatahandle.Data[0].Get()->GetActors());

	FGameplayCueParameters CueParam;
	CueParam.EffectContext = CueContextHandle;

	SourceASC->ExecuteGameplayCue(ABTAG_GAMEPLAYCUE_CHARACTER_ATTACKHIT, CueParam);
}
```


UABGA_Skill를 상속받은 블루프린트
![image](https://github.com/m-mang2/unrealability/assets/135841268/b8137186-ff20-4fda-995f-dd046df9ca1e)


