![image](https://github.com/m-mang2/unrealability/assets/135841268/21664534-fc83-4106-858b-337ba665c82a)


AnimMontage에서 특정 시점에 notify를 설정

![image](https://github.com/m-mang2/unrealability/assets/135841268/8bb2235b-a528-4531-ab43-7685540c519d)

Tag는 SkillHitCheck

![image](https://github.com/m-mang2/unrealability/assets/135841268/724e7807-f79b-48e2-8594-1d6a9a640211)


Character에 SkillHitCheck를 설정

```
for (const auto& StartAbility : StartAbilities)
{
  FGameplayAbilitySpec StartSpec(StartAbility);
  //StartSpec.InputID = InputID++;
  ASC->GiveAbility(StartSpec);
}
```
![image](https://github.com/m-mang2/unrealability/assets/135841268/a8466452-3281-41c5-bfe5-066990d7e458)



GameplayAbility는 AnimMontage의 notify에서 호출이됨

GameplayAbility가 호출이 되면 ActivateAbility내에서 UAbilityTask를 생성하는데 UAbilityTask내에서 판정이 나옴



```
UABAT_Trace* AttackTraceTask = UABAT_Trace::CreateTask(this, AABTA_Trace::StaticClass()); // AGameplayAbilityTargetActor는  UABAT_Trace::CreateTask이용하여 생성
if (AttackTraceTask)
{
	AttackTraceTask->OnComplete.AddDynamic(this, &UABGA_AttackHitCheck::OnTraceResultCallBack);
	AttackTraceTask->ReadyForActivation();
}
```

판정을 위하여  AABTA_SphereMultiTrace라는 객체를 생성하여 FGameplayAbilityTargetDataHandle를 만들어서 넘김
```

FGameplayAbilityTargetDataHandle AABTA_SphereMultiTrace::MakeTargetData() const
{
	ABGAS_LOG(LogABGAS, Log, TEXT("Begin"));

	ACharacter* Character = CastChecked<ACharacter>(SourceActor);

	UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(SourceActor);
	if (ASC == nullptr)
	{
		return FGameplayAbilityTargetDataHandle();
	}

	TArray<FOverlapResult> Overlaps; // 범위에 있는 모든 객체들의 정보
	const float SkillRadius = 600.0f;
	FVector Origin = Character->GetActorLocation();
	FCollisionQueryParams QueryParams(SCENE_QUERY_STAT(AABTA_SphereMultiTrace), false, Character);
	GetWorld()->OverlapMultiByChannel(Overlaps, Origin, FQuat::Identity, CCHANNEL_ABACTION, FCollisionShape::MakeSphere(SkillRadius), QueryParams);


	TArray<TWeakObjectPtr<AActor>> HitActors;
	for (const auto& Overlap : Overlaps)
	{
		AActor *HitActor = Overlap.OverlapObjectHandle.FetchActor<AActor>();
		if (HitActor && HitActors.Contains(HitActor) == false)
		{
			HitActors.Add(HitActor);
		}
	}

	FGameplayAbilityTargetData_ActorArray* ActorData = new FGameplayAbilityTargetData_ActorArray();
	ActorData->SetActors(HitActors);

	return FGameplayAbilityTargetDataHandle(ActorData);
}

```

조건을 체크하여 액터를 넘기면 OnTraceResultCallBack에서 액터들을 확인하여 이펙트를 보냄
```
UAbilitySystemComponent* SourceASC = GetAbilitySystemComponentFromActorInfo_Checked();
FGameplayEffectSpecHandle EffectSpecHandle = MakeOutgoingGameplayEffectSpec(AttackDamageEffect, CurrentLevel);
if (EffectSpecHandle.IsValid())
{
	ApplyGameplayEffectSpecToTarget(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, EffectSpecHandle, TargetDatahandle);

	FGameplayEffectContextHandle CueContextHandle = UAbilitySystemBlueprintLibrary::GetEffectContext(EffectSpecHandle);
	CueContextHandle.AddActors(TargetDatahandle.Data[0].Get()->GetActors());

	FGameplayCueParameters CueParam;
	CueParam.EffectContext = CueContextHandle;

	SourceASC->ExecuteGameplayCue(ABTAG_GAMEPLAYCUE_CHARACTER_ATTACKHIT, CueParam);
}
```


UABGA_Skill를 상속받은 블루프린트
![image](https://github.com/m-mang2/unrealability/assets/135841268/b8137186-ff20-4fda-995f-dd046df9ca1e)


# 스킬 쿨타임과 코스트
게임 어빌리티에 이미 두개가 정의 되어있어서 추가하기만 하면됨

![image](https://github.com/m-mang2/unrealability/assets/135841268/a26d5fa3-2212-4b53-b773-20c8611f4202)

코스트 30(어트리뷰트에 100으로 정의 되어있어서 3번만 사용가능)

![image](https://github.com/m-mang2/unrealability/assets/135841268/b4948adf-ec76-40e7-958d-7a91a907454f)

쿨타임(3초), 쿨타임은 바로 설정이 안되고 tag를 설정해서 값을 보내주고 tag를 이용해서 직접 막아줘야함

![image](https://github.com/m-mang2/unrealability/assets/135841268/74a07a03-b4af-40e2-8dbc-43d4bff7873b)
![image](https://github.com/m-mang2/unrealability/assets/135841268/6e021b74-6a59-4ca5-a2a0-41b1d689a089)
![image](https://github.com/m-mang2/unrealability/assets/135841268/1a13b8c0-29e8-4a09-a251-f88ff11baad5)

# 거리별 데미지 감소
![image](https://github.com/m-mang2/unrealability/assets/135841268/30846558-6bf2-4673-9b7e-c38e26a2c011)

Execute을 오버라이드하여 구현
```
void UABSkillDamageExecutionClac::Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const
{
	Super::Execute_Implementation(ExecutionParams, OutExecutionOutput);

	UAbilitySystemComponent* SourceASC = ExecutionParams.GetSourceAbilitySystemComponent();
	UAbilitySystemComponent* TargetASC = ExecutionParams.GetTargetAbilitySystemComponent();
	if (SourceASC == nullptr || TargetASC == nullptr)
	{
		return;
	}

	AActor* SourceActor = SourceASC->GetAvatarActor();
	AActor* TargetActor = TargetASC->GetAvatarActor();

	if (SourceActor == nullptr || TargetActor == nullptr)
	{
		return;
	}

	const float MaxDamageRange = SourceASC->GetNumericAttributeBase(UABCharacterSkillAttributeSet::GetMaxSkillRangeAttribute());
	const float MaxDamage = SourceASC->GetNumericAttributeBase(UABCharacterSkillAttributeSet::GetMaxSkillAttackRateAttribute());
	
	const float Distance = FMath::Clamp(SourceActor->GetDistanceTo(TargetActor), 0.0f, MaxDamageRange);
	const float InvDamageRatio = 1.0f - Distance /MaxDamageRange;

	float Damage = InvDamageRatio * MaxDamage;

	OutExecutionOutput.AddOutputModifier(FGameplayModifierEvaluatedData(UABCharacterAttributeSet::GetDamageAttribute(), EGameplayModOp::Additive, Damage));
}

```

게임 이펙트에서 Modifiers를 제거하고 Executions를 추가함

![image](https://github.com/m-mang2/unrealability/assets/135841268/5555e523-1c1a-44a2-896e-cec695c9519b)




클래스는 32글자 이내

![image](https://github.com/m-mang2/unrealability/assets/135841268/0823297a-ca42-46e3-8a84-0a51963e74e6)

